// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @dev Converts a short string (up to 30 chars) to uint256.
 * @param str The string to be converted.
 * @return result The uint256 representation of the string.
 */
function stringToUint256(string memory str) pure returns (uint256 result) {
    bytes memory b = bytes(str);
    require(b.length <= 30, "String is too long");
    require(b.length > 0, "Empty string");

    for (uint256 i = 0; i < b.length; i++) {
        result |= uint256(uint8(b[i])) << (8 * (31 - i));
    }
}

/**
 * @dev Converts a uint256 back to a string (up to 30 chars).
 * @param value The uint256 to be converted.
 * @return str The string representation of the uint256.
 */
function uint256ToString(uint256 value) pure returns (string memory str) {
    bytes memory b = new bytes(30);
    require(value > 0, "Empty value");

    for (uint256 i = 0; i < 30; i++) {
        uint8 char = uint8(value >> (8 * (31 - i)));
        if (char != 0) {
            b[i] = bytes1(char);
        }
    }

    // Find the length of the actual string without trailing zeroes
    uint256 actualLength = 0;
    for (uint256 i = 0; i < 30; i++) {
        if (b[i] != 0) {
            actualLength = i + 1;
        }
    }

    // Resize the bytes array to the actual length
    bytes memory result = new bytes(actualLength);
    for (uint256 i = 0; i < actualLength; i++) {
        result[i] = b[i];
    }

    return string(result);
}

/**
 * @title ZKSyncContributor
 * @dev Basic ERC721 token with auto-incrementing token IDs.
 * The owner can mint new tokens. Token URIs are autogenerated based on a base URI.
 */
contract ZKsyncDevNFT is ERC721Enumerable, Ownable {
    constructor() ERC721("ZKSync Contributor", "ZKSyncDev") {}

    function tokenURI(
        uint256 tokenId
    ) public view virtual override returns (string memory) {
        require(
            _exists(tokenId),
            "ERC721Metadata: URI query for nonexistent token"
        );
        return
            string(
                abi.encodePacked("http://github.com/", uint256ToString(tokenId))
            );
    }

    /**
     * @dev Mints a new token to the specified address.
     * Only the owner can mint new tokens.
     * @param to The address that will receive the minted token.
     */
    function mint(
        address to,
        string calldata githubUsername
    ) external onlyOwner {
        _mint(to, stringToUint256(githubUsername));
    }

    function exists(
        string calldata githubUsername
    ) external view returns (bool) {
        return _exists(stringToUint256(githubUsername));
    }

    function githubToToken(
        string calldata githubUsername
    ) external pure returns (uint256) {
        return stringToUint256(githubUsername);
    }

    function tokenToGithub(
        uint256 token
    ) external pure returns (string memory) {
        return uint256ToString(token);
    }
}
